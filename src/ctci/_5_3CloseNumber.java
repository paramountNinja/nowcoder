package ctci;
//@formatter:off
/**
 *                             _ooOoo_
 *                            o8888888o
 *                            88" . "88
 *                            (| -_- |)
 *                            O\  =  /O
 *                         ____/`---'\____
 *                       .'  \\|     |//  `.
 *                      /  \\|||  :  |||//  \
 *                     /  _||||| -:- |||||-  \
 *                     |   | \\\  -  /// |   |
 *                     | \_|  ''\---/''  |   |
 *                     \  .-\__  `-`  ___/-. /
 *                   ___`. .'  /--.--\  `. . __
 *                ."" '<  `.___\_<|>_/___.'  >'"".
 *               | | :  `- \`.;`\ _ /`;.`/ - ` : | |
 *               \  \ `-.   \_ __\ /__ _/   .-` /  /
 *          ======`-.____`-.___\_____/___.-`____.-'======
 *                             `=---='
 *          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 *                     佛祖保佑        永无BUG
 *
 * 描述：有一个正整数，请找出其二进制表示中1的个数相同、且大小最接近的那两个数。(一个略大，一个略小)
 * 给定正整数int x，请返回一个数组，代表所求的两个数（小的在前）。保证答案存在。
 * 测试样例：2返回：[1,4]
 */
 //@formatter:on
public class _5_3CloseNumber {
    public int[] getCloseNumber(int x) {
        int min = x - 1, max = x + 1;
        while (Integer.bitCount(x) != Integer.bitCount(min) && min >= 0) {
            min--;
        }

        while (Integer.bitCount(x) != Integer.bitCount(max)) {
            max++;
        }
        int arr[] = {min, max};
        return arr;
    }
}

/*
这里主要学习Integer.bitCount(x) 还有一种位运算暂时未列出，可以参考书籍。
 */